[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18412081&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is a field within computer science focused on designing, developing, testing, and maintaining of software application.Studying software engineering is crucial to the technology industry as it provides the foundation for developing reliable, efficient, and scalable software applications, which are essential for driving innovation, improving user experiences, and enabling businesses to operate effectively in the digital age; essentially, software engineers are the architects behind the digital products and services that power modern society, from e-commerce platforms to healthcare systems and beyond. 

Identify and describe at least three key milestones in the evolution of software engineering.

Software engineering has come a long way, evolving through major shifts that changed how we build and manage software. Here are three key moments that shaped the field:

 **The Birth of Software Engineering (1968)**

Back in the late 1960s, software development was a bit of a mess—projects were running over budget, missing deadlines, and were full of bugs. At the NATO Software Engineering Conference in 1968, experts started calling this the "software crisis." That’s when the term software engineering was first introduced, pushing for a more structured, disciplined approach to writing code—treating it more like an engineering field rather than a free-for-all.

 **The Rise of Object-Oriented Programming (OOP) (1970s-1980s)**

By the late 1970s and into the 1980s, software was getting more complex, and developers needed a better way to organize their code. That’s when Object-Oriented Programming (OOP) came into play, with languages like Smalltalk, C++, and later Java. Instead of writing one long script, OOP broke programs into smaller, reusable pieces (called objects), making code easier to manage and scale. This approach laid the groundwork for modern software, from mobile apps to large enterprise systems.

**The Agile Revolution (2001-Present)**
Fast forward to the early 2000s, and software teams were still struggling with rigid, slow development processes like Waterfall. In 2001, a group of developers created the Agile Manifesto, which changed everything. Agile introduced a more flexible, iterative way of building software—focusing on teamwork, customer feedback, and adapting to change. It led to popular methods like Scrum and Kanban, which are now the standard for software teams worldwide.

List and briefly explain the phases of the Software Development Life Cycle.

** SDLC has six main stages to go through:**

Analysis: Understanding what users require.
Design: Planning how the software will look and what it will do.
Coding: Putting the plan into an executable file.
Testing: Looking for faults and issues in the software’s functioning.
Deployment: Making the software available to users.
Maintenance: Post-launch, resolving problems and implementing new changes.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

waterfall works after the another is complete. It is useful for projects that have set guidelines, such as creating a government database. Adjustments are difficult after a phase has been completed while Agile divides projects into smaller increments (also known as sprints) and adjusts according to the requirements. It is common in startups for applications where users’ suggestions dictate the changes that are made.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer: Develops functionalities, codes, and debug.
quality assurance Engineer: Evaluates the application to identify errors and verify correctness of the application's functionality.
Project Manager: Ensures the project runs within target objectives and deadlines and serves as a liaison with clients.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

IDEs (e.g. Visual Studio Code): Bring together coding, debugging and testing in one package.
Version Control system(e.g. Git): Saves information on the amendments done on the codes so that, there is smooth cooperation among software developers without misunderstandings.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Scope Creep: This can be managed by preventing scope creep at the outset by establishing precise objectives.
Debugging Issues: Use debugging techniques such as breakpoints and other hands-on methods to speed up finding bugs.
Technical Debt: Refactor bad code.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

unit Tests: Test particular components (for example, a login capability).
Integration Tests: Test whether different modules function correctly together (e.g.,payment system and the shopping cart).
System Tests: Test the complete workings of the application.
Acceptance Tests: Test whether the software delivered meets users’ requirements.
The focus on testing minimizes costs by resolving issues before they escalate.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

**A Definition of Prompt Engineering.**

To prompt engineer means coming up with formulated questions so that AI gives sensible answers. This is important because the words chosen are too generalized for
anything useful to be retrieved.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

**“Discuss Automation cars.”**
Prompt in a better way:
“Discuss the advancement of electric vehicles from the 1990s to the present providing insights on batteries and the carbon footprint that came with it.”

**why impoved prompt is more effective**

The improved prompt is more effective because it provides clearer instructions, more specific details, and better context, which helps guide the response toward a more relevant and high-quality output. it is clear, specific, contextual and actionable
